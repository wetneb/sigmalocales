Require Import MyNotations.
Require Import PreorderEquiv.
Require Import MeetSemiLattice.
Require Import Frame.
Require Import FreeFrame.
Require Import SeqOfList.

(** * Frame structure on [Prop] *)

Section PropFrame.
  Definition implies (a b : Prop) := a -> b.
  Hint Unfold implies.

  Definition Vprop (P : nat -> Prop) := exists n, P n.

  Instance PropPO : Preorder implies.
  Proof.
    apply MkPreorder ; unfold implies ; firstorder.
  Defined.

  Instance PropMSL : MeetSemiLattice implies.
  Proof.
    apply MkMSL with (msl_top := True) (msl_bot := False) (msl_meet := and) ; unfold implies ; firstorder.
  Defined.

  Instance PropFrame : Frame (le := implies).
  Proof.
    apply MkFrame with (frame_msl := PropMSL) (V := Vprop) ; unfold implies, meet, msl_meet, PropMSL, V ; firstorder.
  Defined.

End PropFrame.

(** * Definition of [Sigma]
    We define it as the initial frame (the free frame generated by 
    the trivial meet semilattice). *)

Section Sigma.
  Definition Idx (t : SigmaGen) := False.
  Definition CovAx (t : SigmaGen) (i : Idx t) : (nat -> SigmaGen) :=
    match i with end.
  
  Definition Sigma := (nat -> SigmaGen).
  Instance SigmaLe : Le Sigma.
  Proof.
    unfold Sigma.
    apply Covrel_le with (Tle := SigmaGenLe) (Idx := Idx).
    exact SigmaGenMSL.
    exact CovAx.
  Defined.

  Instance SigmaFrame : Frame := FFrame SigmaGen
                                  SigmaGenLe
                                  SigmaGenMSL
                                  Idx
                                  CovAx.


  Existing Instance Feq_equiv.
  Existing Instance joinb_join.
  Existing Instance SigmaGenLe.
  Existing Instance SigmaGenMSL.
  Existing Instance msl_top.

  Infix "◁" := (covrel SigmaGen SigmaGenLe SigmaGenMSL Idx CovAx) (at level 40).

  Proposition Sigma_V_top : forall u : Sigma, u = ⊤ -> exists n, u n = ⊤.
  Proof.
    intros.
    destruct H as [_ H].
    unfold le, SigmaLe, Covrel_le, Covrel in H.
    specialize (H O).
    assert (forall x, x ◁ u -> x = ⊤ -> exists n, u n = ⊤).
    intros x G.
    induction G.
    - intros.
      exists n. rewrite H0, H1. reflexivity.
    - destruct i.
    - intro.
      rewrite H1 in H0.
      inversion H0. subst.
      apply IHG. apply G. reflexivity.
    - apply H0 with (x := ⊤ O). assumption.
      reflexivity.
  Qed.

  (** ** Properties of [Sigma]

      We use least number search to extract
      a concrete witness that [u = ⊤]. *)

  Require Import LeastNumberSearch.

  Proposition Sigma_V_top_min : forall u : Sigma, u = ⊤ -> { n | min (fun n => u n = ⊤) n }.
  Proof.
    intros.
    apply least_witness.
    - intro.
      destruct (u n).
      + right. intro.
        inversion H0.
        inversion H2.
      + left. reflexivity.
    - apply Sigma_V_top. assumption.
  Qed.

  (** 
    This concrete witness allows us to decide complements in [Sigma].
    *)

  Require Import BijNat.

  Proposition Sigma_join_top : forall a b : Sigma, a ⊔ b = ⊤ -> { a = ⊤ } + { b = ⊤ }.
  Proof.
    intros.
    rewrite (join_NpN SigmaGen SigmaGenLe SigmaGenMSL Idx CovAx) in H.
    apply Sigma_V_top_min in H.
    destruct H, m.
    destruct (bijNpNinv x).
    left. apply Top_n with (n := n). assumption.
    right. apply Top_n with (n := n). assumption.
  Qed.

End Sigma.

(** * Definition of [Nabla2]
    We define it as the frame of double negation closed properties. *)
  
Section Nabla2.
  Hint Unfold equiv le.
  Ltac unfold_selected := repeat autounfold with *.

  Definition Nabla2 := { p : Prop | ~~p -> p }.

  Ltac projNabla2 :=
    repeat (match goal with
      | [ x : Nabla2 |- _ ] => progress (
        match goal with
          | [ H : (~~ `x -> `x) |- _ ] => idtac
          | [ |- _ ] => assert (~~`x -> `x) by (apply proj2_sig)
        end)
    end).

  
  (** ** Frame structure on [Nabla2] *)
  Definition N2le (x y : Nabla2) := ` x -> ` y.
  Instance N2le_le : Le Nabla2 := N2le.
  
  Definition N2and (x y : Nabla2) : Nabla2.
    apply exist with (x := `x /\ `y).
    projNabla2. firstorder.
  Defined.

  Definition N2or (x y : Nabla2) : Nabla2.
    apply exist with (x := ~~ (`x \/ `y)).
    projNabla2. firstorder.
  Defined.

  Definition N2V (P : nat -> Nabla2) : Nabla2.
    apply exist with (x := ~~ (exists n : nat, (` (P n)):Prop)).
    firstorder.
  Defined.

  Definition N2top : Nabla2.
    apply exist with (x := True). firstorder.
  Defined.

  Definition N2bot : Nabla2.
    apply exist with (x := False). firstorder.
  Defined.

  Instance Nabla2PO : Preorder N2le.
    apply MkPreorder ; intros ; projNabla2 ; firstorder.
  Defined.

  Instance Nabla2MSL : MeetSemiLattice N2le.
    apply MkMSL with (msl_top := N2top)
                       (msl_bot := N2bot)
                       (msl_meet := N2and) ;
    intros ; projNabla2 ; firstorder.
  Defined.

  Instance Nabla2Frame : Frame (le := N2le).
    apply MkFrame with (frame_msl := Nabla2MSL)
                         (V := N2V) ;
    intros ; projNabla2 ; firstorder.
  Defined.
  Existing Instance Feq_equiv.
  Hint Unfold Feq_equiv Feq Nabla2Frame N2le_le N2le.

  (** ** Properties of [Nabla2Frame]
      Equality on Nabla2 is just equivalence. *)
  Proposition N2eq_carac : forall x y : Nabla2, x = y <-> (`x <-> `y).
  Proof.
    unfold_selected. intros.
    firstorder.
  Qed.
  
  (** Nabla2 is ~~-separated. *)
  Proposition Nabla2_nnsep : forall x y : Nabla2, ~~(x = y) -> x = y.
  Proof.
    unfold_selected.
    intros.
    projNabla2.
    tauto.
  Qed.

  Lemma contra_lemma : forall A B:Prop, (A -> B) -> (~B -> ~A).
  Proof.
    firstorder.
  Qed.

  Ltac elim_nn := apply contra_lemma ; apply contra_lemma.
  
  (** Nicer version of the join on Nabla2. *)
  Existing Instance joinb_join.
  Proposition N2join_carac : forall x y : Nabla2, ` (x ⊔ y) <-> ~~(`x \/ `y).
  Proof.
    intros.
    unfold join, joinb_join, joinb, Nabla2Frame. simpl.
    split ; elim_nn ; intro.
    - destruct H as [[|[|n]] H] ; simpl in H ; firstorder.
    - unfold V_cons.
      destruct H.
      exists O ; assumption.
      exists (S O) ; assumption.
  Qed.
    
  (** Nabla2 has complements. *)
  Definition N2not (p : Nabla2) : Nabla2.
    apply exist with (x := ~`p).
    firstorder.
  Defined.
  Instance N2not_neg : Negate Nabla2 := N2not.
  
  Proposition N2_complement_join : forall p : Nabla2, p ⊔ - p = ⊤.
  Proof.
    intro.
    rewrite N2eq_carac.
    rewrite N2join_carac.
    unfold negate, N2not_neg, N2not.
    simpl. firstorder.
  Qed.

  Proposition N2_complement_meet : forall p : Nabla2, p ⊓ - p = ⊥.
  Proof.
    intro.
    rewrite N2eq_carac.
    unfold negate, N2not_neg, N2not.
    unfold meet, msl_meet, Nabla2MSL. simpl.
    firstorder.
  Qed.
  
End Nabla2.